# VHDL model

This should implement the same ISA as the emulator, but aims to be
synthesizable inside an FPGA or ASIC.

## How to Build

### Quick Start

For simulation only, you need the GHDL compiler, and possibly GTKWave to
display the simulated waveforms.

If you want to synthesize a bitstream or simulate for the actual hardware,
you need the vendor toolchain. For the Phi board (which is rather seldom,
but the first board implemented here, this would be Intel Quartus 20.1.

There are four scripts inside the `logic/` directory:

sim.sh
: Compile and simulate using GHDL

gen.sh
: Generate the vendor IP blocks for synthesis and simulation

msim.sh
: Simulate using ModelSim

syn.sh
: Synthesize bitstreams

The `display/` directory contains the Vulkan frontend to display the output
generated inside the FPGA. Configure using `./configure` and build with
`make`, as per usual; you need X11 and Vulkan headers and libraries.

## Core

The main CPU core (`cpu`) has separate 64 bit instruction and 32 bit data
buses that are fully synchronous and assumes that any memory interface or
peripherals are external.

### Sequential Implementation

To Be Documented

### Pipelined Implementation

The pipeline should move one step per cycle (ideally), with each stage
working on a different instruction. When a dependency requires the pipeline
to stall, NOPs are inserted until it can proceed.

#### Fetch Stage

This stage fetches the next instruction, and sends it to the decode stage
if the decode stage is ready. The instruction pointer is also kept here
instead of the register map, because it is updated on every instruction,
and the register map only has two ports.

#### Decode Stage

This stage takes the high-level opcode and generates low-level opcodes for
all the following stages, from a table.

#### Register Lookup Stage

This stage fetches values from the register file or one of the feedback
paths.

#### Condition Stage

This evaluates the condition field and sets the "skip" flag if the
instruction should not be executed, and inserts NOPs if evaluation needs to
be delayed.

#### Swap Stage

This stage optionally exchanges lane 2 with the (next) instruction pointer,
to implement jump and call instructions near the beginning of the pipeline.

#### Store Stage

This is a side branch, storing the word in lane 2 to the address in lane 1.

#### ALU Stage

Performs Calculations.

#### Load Stage

Loads lane 2 from the address in lane 1, and notifies the Writeback and
Feedback stages when the result is ready

#### Writeback Stage

Writes values into the register map once they are ready

#### Feedback Path

Implicitly, any register written is made available to following
instructions bypassing the register map, because otherwise we'd incur a
delay of two cycles.

Explicitly, lane 2 can be passed back into the register lookup stage as a
separate source. This is only needed for indirect call instructions.

## Testbench

Testbenches can be run automatically using the `sim.sh` script, and require
GHDL to run, and GtkWave to inspect the waveform data.

### CPU testbench

This testbench loads the "Hello world" example binary, and executes it in
the CPU, then terminates when the CPU stops.
